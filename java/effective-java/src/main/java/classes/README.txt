一 权限控制与可变性
1 可访问性最小化:适用封装隔离API（抽象公共/受保护）和实现（私有/包私有）
// 1 API的分割线为包级私有,类或接口应尽可能为包级私有，若包级私有类或接口只被一个类使用，那么可以考虑这个类作为私有静态嵌套类。
// 2 成员应设计为私有，只有当同一个包中其他类真的需要访问成员时，需要删除私有修饰符变为包私有。如果发现经常这样做，你应该检查类是否需要重新设计
// 3 除静态变量之外（必须不可变,使用不可变视图或Clone以避免可变对象和数组造成的对象间接逸出），实例字段和静态字段不应是共有或受保护的，
// 4 用于测试目的，私有成员指定为包级私有是可以接受的，更高则不行。


2 在公共类中使用访问方法而不是公共属性
// 1 如果一个类在其包之外是可访问的，则提供访问器方法来保留更改类内部表示的灵活性。
// 2 包级私有的类，则不必使用访问器方法。
// 3 公共类暴露不可变属性的危害虽然小，但是也应尽量避免。


3 可变性最小化：除非必要，否则类应该是不可变的
// 1 优先创建不可变类（1）所有字段为private final,（2）禁止继承，（3）不提供set方法，（4）确保可变组件的独占性访问权（入/出/自身，必要时使用防御性拷贝）
// 2 可以使用静态工厂方法对指定范围不可变值进行缓存，减少内存占用，如BigInteger
// 3 提供常用数值，避免中间计算产生大量不可变对象导致的性能和内存损耗，
// 4 禁用继承：使用全部构造器私有化+静态构造器代替final class
// 5 确认有必要实现令人满意的性能时，才应该为不可改变类提供一个公开的可变伙伴类String/StringBuilder。


二 继承与组合
4 要么设计继承并提供文档说明，要么禁用继承
// 1 必须为可继承方法编写实现文档：说明自用模型，即指明方法调用哪些可重写方法，以何种顺序调用的，以及每次调用的结果又是如何影响后续处理，
//      同时这个类的整个生命周期中都必须遵守该文档，如果没有做到，子类就会依赖父类的实现细节，如果父类的实现发生了变化，它就有可能遭到破坏。
// 2 类必须以精心挑选的protected方法的形式，提供适当的钩子，以便进入其内部工作中，使程序员能够编写出更加有效的子类
// 3 测试为继承而设计的类的唯一方法是编写子类。 如果你忽略了一个关键的受保护的成员，试图编写一个子类将会使得遗漏痛苦地变得明显。
//      相反，如果编写的几个子类，而且没有一个使用受保护的成员，那么应该将其设为私有。 经验表明，三个子类通常足以测试一个可继承的类。
// 4 构造方法绝不能直接或间接调用可重写的方法,因为父类构造器会先于子类构造器运行
// 5 除抽象类/接口骨架实现之外的普通类应禁止继承，如果非要继承，可以使用私有帮助函数机械消除自用性
// 6 clone/readObject都不应直接或间接调用可重写的方法，同时若存在readResolve或writeReplace方法，此两个方法不应是私有的


5 类层次结构优于带标签的类,不应该使用标签类
// 1 标签类：充斥样板代码，可读性受损，内存占用高，耦合严重。
// 2 继承类：清晰明了，符合开闭和解耦，同时能清晰反应各类型之间的关系


6 组合优于继承
// 1 包内继承是安全的，因为在同一人的控制下，专门为了继承而设计，且有文档说明的类继承也是安全的，其他则是危险的
// 2 继承属于白盒复用，打破了封装性，子类将受到父类自用性的影响
// 3 父类在以后的版本中增加新方法，有可能会破坏子类的一致性约束，以及出现签名冲突或意外的重写
// 4 使用组合与转发代替继承，避免父类影响
// 5 包装类不适合回调框架，对性能和内存基本无影响
// 6 继承前请慎重考虑，是否真正属于父子关系，父类是否有缺陷，如果只需要部分父类功能，请使用组合，避免多余的功能破坏子类。

三 接口与抽象类
7 接口优于抽象类
// 1 抽象类只能单继承，无法构造非层次化类型框架
// 2 抽象类迫使使用者继承，而无以组合的方式使用包装类
// 3 接口的默认方法，要使用@implSpec说明自用模型
// 4 编写基于模板方法的接口及其抽象骨架实现类：
        （1）研究接口并决定哪些方法是基本方法，为所有可以在基本方法之上实现的方法提供默认方法，
        （2）如果基本方法和默认方法覆盖了接口，那么就完成了，不需要一个骨架实现类。
        （3）否则，编写一个声明为实现接口的类，并实现所有剩余的接口方法。该类可能包含任何适合于任务的非公共字段和方法。


8 为后代设计接口
// 1 虽然默认方法使向现有接口添加方法成为可能，但这样做存在很大风险。
//      如果默认方法未被覆盖，则可能破坏实现类不变性条件；
//      如果默认方法被覆盖，但是返回类型不兼容，则会运行时报错；
//      如果默认方法被覆盖，但是与官方语义不同，则会造成误解
// 2 如果非要使用默认方法向现有接口添加新方法，应该仔细考虑现有接口实现是否可能被默认方法破坏。
// 3 尽管默认方法现在已经是Java平台的一部分，但是谨慎地设计接口仍然是非常重要的。
//      你应该以三种不同的实现为目标。同样重要的是编写多个客户端程序，用这些程序使用每个新接口的实例来执行各种任务。


9 接口只用于定义类型
// 1 不应在接口和可继承的类中使用常量模式,不仅会将实现细节泄漏到类的导出API中,同时该常量会污染子类的命名空间
// 2 常量应使用枚举类或不可实例化的静态工具类导出

四 嵌套类与类文件
10 静态成员类优于非静态成员类
// 1 嵌套类应该只为外部类服务。如果嵌套类在其他环境中有用，那么它应该是顶级类。
// 2 静态成员类的一个常见用法是作为公有的辅助类，只有与它的外部类一起使用时才有意义。
// 私有静态成员类的一个常见用法是表示由其外部类表示的对象的组件。
// 3 非静态成员类的一个常见用法是定义一个Adapter,允许外部类的实例被视为某个不相关类的实例。
// 例如，Map的集合视图，List的迭代器
// 4 匿名类的另一个常见用法是实现静态工厂方法,动态创建小型函数对象和进程对象(已被lambda代替)
// 5 局部类基本不怎么使用


11 源文件仅限有单个顶层类
// 1 一个源文件只能有一个顶层类，以防止同一个包内存在重名类
// 2 将多个顶层类放到一个源文件中,请考虑使用静态成员类