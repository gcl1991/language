1 优先选择Java序列化的替代方案
(1) 使用JSON和Protocol Buffers代替序列化
(2) 永远不要反序列化不可信的数据, 使用反序列化筛选工具，增加黑白名单

2 序列化的缺陷
(1) 类中私有的包以及私有实例字段将成为其导出API的一部分,需要使用@serial对私有字段进行文档化,以及@serialData对writeObject等方法文档化。
(2) 反序列化都是一个隐藏构造函数,依赖于默认的反序列化机制,会让对象轻易地遭受不变性破坏和非法访问
(3) 各版本之间序列化-反序列化测试负担较重
(4) 为继承而设计的类很少情况适合实现序列化，其存在2个风险，同时会给扩展类或实现接口的任何人带来很大的负担。
(5) 实例内部类不应该实现序列化，其合成字段的默认序列化形式是不确定的。

3 如何编写JAVA序列化
(1) 如果对象的物理表示与其逻辑内容相同，则默认的序列化形式可能是合适的，否则不要使用默认序列化（存在4个缺点）。
    即使你认为默认的序列化形式是合适的，你通常也必须提供 readObject 方法来确保不变性和安全性。
(2) writeObject做的第一件事是调用defaultWriteObject,readObject做的第一件事是调用defaultReadObject,以保留向后和向前兼容性
(3) 哈希序列化与反序列化不能保证反序列后生成原始对象的无差错副本(哈希函数的桶位)
(4) transient：派生字段，与JVM的一个特定运行相关联，比如表示指向本机数据结构指针的long字段，
    non-transient必须是对象逻辑状态的一部分，当反序列化实例时transient字段将初始化为默认值。
    如果这些transient字段的值都是不可接受的，则必须提供一个 readObject方法，然后将transient字段恢复为可接受的值
(5) 线程安全的类需要对writeObject等方法进行同步
(6) 无论选择哪种序列化形式，都要在编写的每个可序列化类中声明显式的序列版本UID

4 使用readObject防范序列化攻击：保护性的编写readObject方法
(1) 约束性检查：readObject方法实际上相当于另外一个公有的构造器，必须检查其参数的有效性，避免攻击者创建无效的Period实例。
(2) 保护性拷贝：可序列化的不可变类，如果它包含了私有的可变字段，那么在它的 readObject 方法中，必须要对这些字段进行保护性拷贝，避免攻击者伪造字节流，创建可变的实例。
(3) 外部方法：readObject无论是直接方法还是间接方法，都不要调用类中任何可被覆盖的方法。

5 使用代理防范序列化攻击：考虑用序列化代理代替序列化实例
(1) 优点：① 可以阻止伪字节流的攻击。② 内部字段的盗用攻击。③ 支持不可变序列化类。④ 可以动态控制更改反序列化对象
(2) 缺点：① 不能与可以被客户端拓展的类兼容。② 它也不能与对象图中包含循环的某些类兼容。③ 会降低性能。

6 序列化与实例控制：枚举类型优于readResolve
(1) 序列化：可以通过在readResolve中使用非transient实现序列化对象替换,破坏单例
(2) 枚举：无此风险，为什么？如何实现？


