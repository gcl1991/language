// 覆盖 equals 方法时应遵守的约定
1 不需要覆盖equals：不需要提供逻辑相等，equals方法永远不会被调用,每个实例本质上都是唯一的,超类equals适合子类
2 反身性/对称性/传递性/一致性/非空性
3 继承体系/里氏替换/传递性和对称性之前的不兼容，可使用抽象类与转发类使之兼容

// 当覆盖 equals 方法时，总要覆盖 hashCode 方法
1 equals是hashCode的充分条件，hashCode是equals的必要条件，equals相等hashCode不应改变，equals不同hashCode尽量不同
2 如何计算散列码：霍纳法则，基本类型调用包装类Type.hashCode(f)，对象类型递归调用hashCode,数组类型调用Arrays.hashCode或所需成员的hashCode，空值以0代替
3 不要为 hashCode 返回的值提供详细的规范，避免客户端依赖，尽量选择均匀性分布好的散列函数。

// 考虑实现 Comparable 接口
1 需要满足基于比较关系和自反性/对称性/传递性/一致性/非空性
2 需要与equals保持一致性

// 明智地覆盖 clone 方法
1 需要满足同类型+不同实例+逻辑相等
2 父类实现Cloneable了接口，父类clone必须调用super.clone()，除非禁用继承
3 处理可变对象深拷贝和浅拷贝的问题
4 使用复制构造函数或复制工厂代替clone
5 缺陷：依赖于易发生风险的语言外对象创建机制；要求无法强制执行的约定；与最终字段的正确使用冲突；会抛出不必要的检查异常；需要强制类型转换。

// 始终覆盖 toString 方法
1 无论你是否决定指定格式（指定toString标准格式（API，类似序列化，后期不可改动）或典型格式），你都应该清楚地在文档上记录你的意图
2 无论你是否指定了格式，都要提供对toString返回值中包含的信息的程序性访问，不要迫使需要这些信息的程序员解析字符串。

