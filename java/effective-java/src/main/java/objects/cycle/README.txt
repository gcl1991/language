一 对象的创建
1 考虑以静态工厂方法代替构造函数
// 静态工厂优点：（1）有确切名称（2）不需要在每次调用时创建新对象（3）可控的返回类型
// 静态工程缺点：（1）不能子类化（2）需要提示使用者发现静态工厂方法

2 当构造函数有多个参数时，考虑改用构建器
// 1 应对必要参数与可选参数的三种方式：可伸缩构造函数模式，Java Bean的Get/Set模式, 建造者模式
// 2 相比与其他两种方式，建造者模式灵活，且适合于类层次结构，增加新参数较容易
// 3 缺点是编程繁琐，有性能损失

3 使用私有构造函数或枚举类型实施单例属性
// 实现单例的三种方式：静态字段，静态方法，枚举
// 防止单例破坏：防反射，防序列化，防止以任何方式构建第2个新对象

4 使用私有构造函数实施不可实例化的静态工具类

5 避免创建不必要的对象
// 1 避免隐晦创建不必要对象：创建相同的字符串，自动装箱,正则表达式模板
// 2 使用静态工厂复用对象
// 3 避免创建相同的正则表达式模板
// 4 因为适配器的状态不超过其支持对象的状态，不需要为给定对象创建一个给定适配器的多个实例。
// 5 慎重使用对象池/延迟初始化进行对象复用

二 对象的释放
6 删除过时的对象引用
// 1 一个类管理它自己的内存时，程序员应该警惕内存泄漏,如数组，存储池
// 2 另外两种常见的内存泄漏源是缓存和侦听器及回调函数，可使用WeakHashMap解决

7 避免使用终结器和清除器
// 1 终结器和清除器的一个缺点是不能保证它们会被立即执行,不能保证它们能运行。
// 2 System.gc/System.runFinalization/System.runFinalizersOnExit可能增加终结器或清除器被运行的几率，但它们不能保证一定运行。
// 3 终结器另一个问题是，在终结期间抛出的未捕获异常将被忽略，同时将finalize方法将终止
//   这可能会使其他对象处于损坏状态,特别是在构造函数和反序列期间，这将导致安全漏洞。
// 4 使用终结器和清除器会严重影响性能。这主要是因为终结器抑制了有效的垃圾收集
// 5 资源应使用AutoCloseable关闭,同时必须跟踪是否已经关闭，如果在对象关闭后调用它们，则必须抛出一个IllegalStateException。
// 6 Cleaner有两个“合理”用途：一种是充当一个安全网,第二个合法使用涉及到与本机对等体的对象

三 资源释放
8 使用try-with-resources替代try-finally释放AutoCloseable资源，因为try-finally将造成异常覆盖和异常丢失

9 依赖注入优于硬连接资源
// 1 不要使用单例或静态实用工具类来实现依赖于一个或多个底层资源的类
// 2 使用依赖注入来实现依赖于一个或多个底层资源的类

