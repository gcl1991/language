一 异常的种类：
1 异常应该只用于异常的情况下, 不应用于正常的程序控制流程, 不强迫客户端为了正常的控制流程而使用异常。
2 断言：代表调用者和被调用的约定，仅在开发测试阶段使用。
3 可控异常：强迫处理或传播，提高可靠性，但增加了负担，违反开闭和封装原则，难以在Stream中使用。
4 不可控异常：RuntimeException（编程错误/前提违例）和Error（资源不足）不需要也不应该被捕获, 属于不可恢复的情形。
5 状态测试方法：不适合并发环境/状态测试代价太高则慎用，可读性好
6 optional返回值：缺点是无法返回任何额外的信息来详细说明它无法执行你想要的计算。
7 可识别的返回值：容易导致忘记检查识别码，引起BUG(不要返回null,禁止接收null,使用Optional的map方法处理多级null值)
8 异常和返回码主要区别：异常强制处理，而返回码则不强制（容易导致忘记检查识别码，导致BUG）

二 异常的构造：
1 不要直接重用Throwable,Error,Exception，RuntimeException，对待这些类要像对待抽象类一样。
2 不应继承Error和throwable, 不可控继承RuntimeException,可控继承Exception
3 优先使用标准异常：沟通学习成本低，避免新类加载,但这种重用必须建立在语义的基础上，而不是建立在名称的基础之上。
4 在细节消息中包含失败一捕获信息(面向程序员，信息优于可读性),应简洁且包含价值的字段和参数，不可包含敏感信息。不应让使用者解析异常的字符串,要在受检异常上提供方法，以便协助程序恢复。
5 用户层次错误：面向用户，必须是可理解的。

三 异常抛出：
1 对于程序错误/调用者无法恢复失败/不确定是否可恢复，就应该抛出未受检异常。
2 对于可恢复情况，并且想要迫使调用者处理异常的条件，首选应该使用3种方式代替可控异常(状态测试/Optional/返回码)。
3 当且仅当万一失败时，这些无法提供足够的信息，才应该抛出受检异常。

四 异常捕获：
1 首先通过参数检查避免不可控异常——>不可避免则捕获并记录异常——>不可捕获异常转译/异常链(避免/记录/转译)
2 异常转译:高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常，以尽量符合开闭原则。
3 异常链(受抑制异常同理)，如果低层的异常对于调试导致高层异常的问题非常有帮助，使用异常链就很合适。
4 不要忽略异常，忽略异常要用充足的理由，必须保证不影响程序的正确性，必须保证不会隐藏问题。

五 异常文档
1 只有main方法它可以被安全地声明抛出Exception
2 始终要单独地声明受检/未受检异常,方法的声明中throws关键字只包含受检异常，以区分受检和非受检异常。
3 A调用B,A中要捕获转译/直接抛出B导致的受查异常,并建立文档。对于B中不可控异常进行首先进行参数检查以避免异常。
4 如果一个类中的许多方法出于同样的原因而抛出同一个异常，在该类的文档注释中对这个异常建立文档，这是可以接受的

六 保持失败原子性：
方法1 使用不可变对象
方法2 执行操作前检查参数的有效性/调整计算顺序,使得可能会失败的计算部分在对象状态被修改之前发生
方法3 建立临时拷贝
方法4 做法是编写一段恢复代码，拦截操作过程中发生的失败，以便对象回滚到操作开始之前的状态上
